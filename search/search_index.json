{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00cdndice de contenidos \u00cdndice con las diferentes secciones de los contenidos de la documentaci\u00f3n: Elementos de Python Ejecuci\u00f3n y Depuraci\u00f3n Pruebas Sandbox Reflexi\u00f3n C\u00f3digo fuente Tests","title":"1. \u00cdndice"},{"location":"#indice-de-contenidos","text":"\u00cdndice con las diferentes secciones de los contenidos de la documentaci\u00f3n: Elementos de Python Ejecuci\u00f3n y Depuraci\u00f3n Pruebas Sandbox Reflexi\u00f3n C\u00f3digo fuente Tests","title":"\u00cdndice de contenidos"},{"location":"codigofuente/","text":"Codigo fuente En este apartado adjunto el c\u00f3digo fuente del programa. Estos archivos pueden contener errores no corregidos. Las versiones corregidas est\u00e1n dentro de los diferentes apartados de la actividad. Descargar c\u00f3digo lavadero.py Descargar c\u00f3digo main_app.py","title":"7. C\u00f3digo fuente"},{"location":"codigofuente/#codigo-fuente","text":"En este apartado adjunto el c\u00f3digo fuente del programa. Estos archivos pueden contener errores no corregidos. Las versiones corregidas est\u00e1n dentro de los diferentes apartados de la actividad. Descargar c\u00f3digo lavadero.py Descargar c\u00f3digo main_app.py","title":"Codigo fuente"},{"location":"ejecucion_depuracion/","text":"Ejecuci\u00f3n y Depuraci\u00f3n En este apartado muestro, en primer lugar, la correcci\u00f3n del c\u00f3digo y, a continuaci\u00f3n, la ejecuci\u00f3n y depuraci\u00f3n del c\u00f3digo. Pueden verse en cada apartado las correcciones realizadas. 1. Correcci\u00f3n del c\u00f3digo En mi IDE, utilizar\u00e9 la herramienta de Ejecuci\u00f3n y Depuraci\u00f3n que viene integrada en el entorno para ejecutar, depurar, ver los errores del c\u00f3digo y corregirlos. En primer lugar, desde la propiar herramienta de depuraci\u00f3n crear\u00e9 un archivo .json para la automatizaci\u00f3n de la depuraci\u00f3n. En mi caso, le he creado dentro del propio proyecto y muestro la herramienta preparada para depurar los archuvos. Error 1. Iniciar un lavado estando ocupado: El tipo de excepci\u00f3n que se produce no es correcto, debe lanzarse ValueError y no RuntimeError . Mediante la ejecuci\u00f3n de dos llamadas consecutivas al m\u00e9todo hacerLavado sin finalizar el primer ciclo, y usando un breakpoint en la validaci\u00f3n de estado, compruebo que el sistema detecta que el lavadero est\u00e1 ocupado y lanza una excepci\u00f3n. Soluci\u00f3n: raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") Ejemplo a\u00f1adido al main para ejecutar la depuraci\u00f3n y probar el error: lavadero_error = Lavadero() try: # Primer lavado (arranca correctamente) lavadero_error.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) print(\"Primer lavado iniciado correctamente\") # Segundo lavado SIN terminar el primero lavadero_error.hacerLavado(prelavado_a_mano=True, secado_a_mano=False, encerado=False) except Exception as e: print(f\"EXCEPCI\u00d3N CAPTURADA: {type(e).__name__} -> {e}\") # Esperado: RuntimeError Error 2. Precio incorrecto del secado a mano: Seg\u00fan el enunciado, el total deber\u00edan de ser 6\u20ac y no 6,20\u20ac. Soluci\u00f3n: if self.__secado_a_mano: coste_lavado += 1.00 Ejemplo a\u00f1adido al main para ejecutar la depuraci\u00f3n y probar el error: print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 3: Precio incorrecto del secado a mano\") lavadero_error3 = Lavadero() # Lavado SOLO con secado a mano lavadero_error3.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=False) # Avanzamos SOLO UNA FASE para que se cobre lavadero_error3.avanzarFase() print(f\"Ingresos tras el cobro: {lavadero_error3.ingresos:.2f} \u20ac\") Error 3: Fase incorrecta tras rodillos (condici\u00f3n invertida): Sin secado a mano deber\u00eda de pasar a secado autom\u00e1tico (fase 6). Soluci\u00f3n: elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO else: self.__fase = self.FASE_SECADO_AUTOMATICO Ejemplo a\u00f1adido al main para ejecutar la depuraci\u00f3n y probar el error: print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano)\") lavadero_error4 = Lavadero() # Lavado SIN secado a mano lavadero_error4.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) # Avanzamos fases manualmente while lavadero_error4.ocupado: print(f\"Fase actual: {lavadero_error4.fase}\") lavadero_error4.avanzarFase() print(f\"Fase final: {lavadero_error4.fase}\") Error 4. La fase de encerado (fase 8) nunca se ejecuta: La fase 8 nunca se ejecuta, incumpliendo el enunciado. Soluci\u00f3n: elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO else: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() Ejemplo a\u00f1adido al main para ejecutar la depuraci\u00f3n y probar el error: print(\"\\=======================================================\") print(\"EJEMPLO ERROR 5: La fase de encerado nunca se ejecuta\") lavadero_error5 = Lavadero() # Lavado con secado a mano y encerado lavadero_error5.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=True) # Avanzamos fases y mostramos todas while lavadero_error5.ocupado: print(f\"Fase actual: {lavadero_error5.fase}\") lavadero_error5.avanzarFase() print(f\"Fase final: {lavadero_error5.fase}\") 2. C\u00f3digo corregido A continuaci\u00f3n muestro el c\u00f3digo completo del programa con los errores comentados corregidos: main_app.py # main_app.py # Importar la clase desde el otro archivo (m\u00f3dulo) from lavadero import Lavadero # MODIFICACI\u00d3N CLAVE AQU\u00cd: La funci\u00f3n ahora acepta 3 argumentos def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado): \"\"\" Simula el proceso de lavado para un veh\u00edculo con las opciones dadas. Ahora acepta una instancia de lavadero. :param lavadero: Instancia de Lavadero. :param prelavado: bool, True si se solicita prelavado a mano. :param secado_mano: bool, True si se solicita secado a mano. :param encerado: bool, True si se solicita encerado. \"\"\" # Se muestran las opciones solicitadas al inciar el lavado. Se muestran las excepciones print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\") # Mostrar las opciones solicitadas print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\") # 1. Iniciar el lavado try: # Esto establece las opciones y pasa a Fase 0 (Inactivo, pero Ocupado=True) lavadero.hacerLavado(prelavado, secado_mano, encerado) print(\"\\nCoche entra. Estado inicial:\") lavadero.imprimir_estado() # 2. Avanza por las fases print(\"\\nAVANZANDO FASE POR FASE:\") # Usamos un contador para evitar bucles infinitos en caso de error o bucles inesperados pasos = 0 while lavadero.ocupado and pasos < 20: # El cobro ahora ocurre en la primera llamada a avanzarFase (transici\u00f3n 0 -> 1) lavadero.avanzarFase() print(f\"-> Fase actual: \", end=\"\") lavadero.imprimir_fase() print() pasos += 1 print(\"\\n----------------------------------------\") print(\"Lavado completo. Estado final:\") lavadero.imprimir_estado() print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\") print(\"----------------------------------------\") except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2) print(f\"ERROR DE ARGUMENTO: {e}\") except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3) print(f\"ERROR DE ESTADO: {e}\") except Exception as e: print(f\"ERROR INESPERADO: {e}\") # Punto de entrada (main): Aqu\u00ed pasamos los par\u00e1metros if __name__ == \"__main__\": lavadero_global = Lavadero() # Usamos una \u00fanica instancia para acumular ingresos \"\"\"\" # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14) # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True) # EJEMPLO 2: Lavado r\u00e1pido sin extras (Requisito 9) # Precio esperado: 5.00 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False) # EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2) print(\"\\n=======================================================\") print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True) # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 2: Intentar iniciar un lavado estando ocupado\") \"\"\" # EJEMPLO ERROR 2: Intentar iniciar un lavado estando ocupado (Requisito 3) \"\"\" lavadero_error = Lavadero() try: # Primer lavado (arranca correctamente) lavadero_error.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) print(\"Primer lavado iniciado correctamente\") # Segundo lavado SIN terminar el primero lavadero_error.hacerLavado(prelavado_a_mano=True, secado_a_mano=False, encerado=False) except Exception as e: print(f\"EXCEPCI\u00d3N CAPTURADA: {type(e).__name__} -> {e}\") # Esperado: RuntimeError \"\"\" # EJEMPLO ERROR 3: Precio incorrecto del secado a mano (Requisito 7) \"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 3: Precio incorrecto del secado a mano\") lavadero_error3 = Lavadero() # Lavado SOLO con secado a mano lavadero_error3.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=False) # Avanzamos SOLO UNA FASE para que se cobre lavadero_error3.avanzarFase() print(f\"Ingresos tras el cobro: {lavadero_error3.ingresos:.2f} \u20ac\") \"\"\" # EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano) (Requisito 13) \"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano)\") lavadero_error4 = Lavadero() # Lavado SIN secado a mano lavadero_error4.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) # Avanzamos fases manualmente while lavadero_error4.ocupado: print(f\"Fase actual: {lavadero_error4.fase}\") lavadero_error4.avanzarFase() print(f\"Fase final: {lavadero_error4.fase}\") \"\"\" # EJEMPLO ERROR 5: Fase incorrecta tras rodillos (con secado a mano y encerado) (Requisito 13) \"\"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 5: La fase de encerado nunca se ejecuta\") lavadero_error5 = Lavadero() # Lavado con secado a mano y encerado lavadero_error5.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=True) # Avanzamos fases y mostramos todas while lavadero_error5.ocupado: print(f\"Fase actual: {lavadero_error5.fase}\") lavadero_error5.avanzarFase() print(f\"Fase final: {lavadero_error5.fase}\") \"\"\" \"\"\" # EJEMPLO ERROR 6: Uso de atributo inexistente self.lavadero print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 6: Uso de atributo inexistente self.lavadero\") lavadero_error6 = Lavadero() # Llamamos al m\u00e9todo de prueba lavadero_error6.ejecutar_y_obtener_fases(prelavado=False, secado=False, encerado=False) \"\"\" lavadero.py: # lavadero.py class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" # A continuaci\u00f3n, las constantes, que ser\u00e1n las diferentes fases del lavadero. # El uso de estas constantes mejora la legibilidad y el mantenimiento del c\u00f3digo. FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 # Tenemos el constructor de la clase. Encargado de inicializar el lavaderio. # Podemos ver tambi\u00e9n los atributos privados del lavadero. def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() # Propiedades. Nos permiten acceder a los atributos privados de forma controlada. @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado # M\u00e9todos principales. # Las dos siguientes funciones sirven para controlar el ciclo de lavado. def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" # Condiciones. if self.__ocupado: raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado # Ingresos def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.00 if self.__encerado: coste_lavado += 1.00 self.__ingresos += coste_lavado return coste_lavado # Avance de las fases. # Se implementa la l\u00f3gica de avance de fases del lavadero. def avanzarFase(self): if not self.__ocupado: return if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO else: self.__fase = self.FASE_SECADO_AUTOMATICO elif self.__fase == self.FASE_SECADO_MANO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") # Muestra por pantalla. # Se muesteran por pantalla la fase actual y el estado del lavadero. def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # Pruebas unitarias # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self._hacer_lavado(prelavado, secado, encerado) fases_visitadas = [self.fase] while self.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.avanzarFase() fases_visitadas.append(self.fase) return fases_visitadas","title":"3. Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"ejecucion_depuracion/#ejecucion-y-depuracion","text":"En este apartado muestro, en primer lugar, la correcci\u00f3n del c\u00f3digo y, a continuaci\u00f3n, la ejecuci\u00f3n y depuraci\u00f3n del c\u00f3digo. Pueden verse en cada apartado las correcciones realizadas.","title":"Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"ejecucion_depuracion/#1-correccion-del-codigo","text":"En mi IDE, utilizar\u00e9 la herramienta de Ejecuci\u00f3n y Depuraci\u00f3n que viene integrada en el entorno para ejecutar, depurar, ver los errores del c\u00f3digo y corregirlos. En primer lugar, desde la propiar herramienta de depuraci\u00f3n crear\u00e9 un archivo .json para la automatizaci\u00f3n de la depuraci\u00f3n. En mi caso, le he creado dentro del propio proyecto y muestro la herramienta preparada para depurar los archuvos. Error 1. Iniciar un lavado estando ocupado: El tipo de excepci\u00f3n que se produce no es correcto, debe lanzarse ValueError y no RuntimeError . Mediante la ejecuci\u00f3n de dos llamadas consecutivas al m\u00e9todo hacerLavado sin finalizar el primer ciclo, y usando un breakpoint en la validaci\u00f3n de estado, compruebo que el sistema detecta que el lavadero est\u00e1 ocupado y lanza una excepci\u00f3n. Soluci\u00f3n: raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") Ejemplo a\u00f1adido al main para ejecutar la depuraci\u00f3n y probar el error: lavadero_error = Lavadero() try: # Primer lavado (arranca correctamente) lavadero_error.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) print(\"Primer lavado iniciado correctamente\") # Segundo lavado SIN terminar el primero lavadero_error.hacerLavado(prelavado_a_mano=True, secado_a_mano=False, encerado=False) except Exception as e: print(f\"EXCEPCI\u00d3N CAPTURADA: {type(e).__name__} -> {e}\") # Esperado: RuntimeError Error 2. Precio incorrecto del secado a mano: Seg\u00fan el enunciado, el total deber\u00edan de ser 6\u20ac y no 6,20\u20ac. Soluci\u00f3n: if self.__secado_a_mano: coste_lavado += 1.00 Ejemplo a\u00f1adido al main para ejecutar la depuraci\u00f3n y probar el error: print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 3: Precio incorrecto del secado a mano\") lavadero_error3 = Lavadero() # Lavado SOLO con secado a mano lavadero_error3.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=False) # Avanzamos SOLO UNA FASE para que se cobre lavadero_error3.avanzarFase() print(f\"Ingresos tras el cobro: {lavadero_error3.ingresos:.2f} \u20ac\") Error 3: Fase incorrecta tras rodillos (condici\u00f3n invertida): Sin secado a mano deber\u00eda de pasar a secado autom\u00e1tico (fase 6). Soluci\u00f3n: elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO else: self.__fase = self.FASE_SECADO_AUTOMATICO Ejemplo a\u00f1adido al main para ejecutar la depuraci\u00f3n y probar el error: print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano)\") lavadero_error4 = Lavadero() # Lavado SIN secado a mano lavadero_error4.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) # Avanzamos fases manualmente while lavadero_error4.ocupado: print(f\"Fase actual: {lavadero_error4.fase}\") lavadero_error4.avanzarFase() print(f\"Fase final: {lavadero_error4.fase}\") Error 4. La fase de encerado (fase 8) nunca se ejecuta: La fase 8 nunca se ejecuta, incumpliendo el enunciado. Soluci\u00f3n: elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO else: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() Ejemplo a\u00f1adido al main para ejecutar la depuraci\u00f3n y probar el error: print(\"\\=======================================================\") print(\"EJEMPLO ERROR 5: La fase de encerado nunca se ejecuta\") lavadero_error5 = Lavadero() # Lavado con secado a mano y encerado lavadero_error5.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=True) # Avanzamos fases y mostramos todas while lavadero_error5.ocupado: print(f\"Fase actual: {lavadero_error5.fase}\") lavadero_error5.avanzarFase() print(f\"Fase final: {lavadero_error5.fase}\")","title":"1. Correcci\u00f3n del c\u00f3digo"},{"location":"ejecucion_depuracion/#2-codigo-corregido","text":"A continuaci\u00f3n muestro el c\u00f3digo completo del programa con los errores comentados corregidos: main_app.py # main_app.py # Importar la clase desde el otro archivo (m\u00f3dulo) from lavadero import Lavadero # MODIFICACI\u00d3N CLAVE AQU\u00cd: La funci\u00f3n ahora acepta 3 argumentos def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado): \"\"\" Simula el proceso de lavado para un veh\u00edculo con las opciones dadas. Ahora acepta una instancia de lavadero. :param lavadero: Instancia de Lavadero. :param prelavado: bool, True si se solicita prelavado a mano. :param secado_mano: bool, True si se solicita secado a mano. :param encerado: bool, True si se solicita encerado. \"\"\" # Se muestran las opciones solicitadas al inciar el lavado. Se muestran las excepciones print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\") # Mostrar las opciones solicitadas print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\") # 1. Iniciar el lavado try: # Esto establece las opciones y pasa a Fase 0 (Inactivo, pero Ocupado=True) lavadero.hacerLavado(prelavado, secado_mano, encerado) print(\"\\nCoche entra. Estado inicial:\") lavadero.imprimir_estado() # 2. Avanza por las fases print(\"\\nAVANZANDO FASE POR FASE:\") # Usamos un contador para evitar bucles infinitos en caso de error o bucles inesperados pasos = 0 while lavadero.ocupado and pasos < 20: # El cobro ahora ocurre en la primera llamada a avanzarFase (transici\u00f3n 0 -> 1) lavadero.avanzarFase() print(f\"-> Fase actual: \", end=\"\") lavadero.imprimir_fase() print() pasos += 1 print(\"\\n----------------------------------------\") print(\"Lavado completo. Estado final:\") lavadero.imprimir_estado() print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\") print(\"----------------------------------------\") except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2) print(f\"ERROR DE ARGUMENTO: {e}\") except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3) print(f\"ERROR DE ESTADO: {e}\") except Exception as e: print(f\"ERROR INESPERADO: {e}\") # Punto de entrada (main): Aqu\u00ed pasamos los par\u00e1metros if __name__ == \"__main__\": lavadero_global = Lavadero() # Usamos una \u00fanica instancia para acumular ingresos \"\"\"\" # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14) # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True) # EJEMPLO 2: Lavado r\u00e1pido sin extras (Requisito 9) # Precio esperado: 5.00 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False) # EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2) print(\"\\n=======================================================\") print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True) # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 2: Intentar iniciar un lavado estando ocupado\") \"\"\" # EJEMPLO ERROR 2: Intentar iniciar un lavado estando ocupado (Requisito 3) \"\"\" lavadero_error = Lavadero() try: # Primer lavado (arranca correctamente) lavadero_error.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) print(\"Primer lavado iniciado correctamente\") # Segundo lavado SIN terminar el primero lavadero_error.hacerLavado(prelavado_a_mano=True, secado_a_mano=False, encerado=False) except Exception as e: print(f\"EXCEPCI\u00d3N CAPTURADA: {type(e).__name__} -> {e}\") # Esperado: RuntimeError \"\"\" # EJEMPLO ERROR 3: Precio incorrecto del secado a mano (Requisito 7) \"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 3: Precio incorrecto del secado a mano\") lavadero_error3 = Lavadero() # Lavado SOLO con secado a mano lavadero_error3.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=False) # Avanzamos SOLO UNA FASE para que se cobre lavadero_error3.avanzarFase() print(f\"Ingresos tras el cobro: {lavadero_error3.ingresos:.2f} \u20ac\") \"\"\" # EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano) (Requisito 13) \"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano)\") lavadero_error4 = Lavadero() # Lavado SIN secado a mano lavadero_error4.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) # Avanzamos fases manualmente while lavadero_error4.ocupado: print(f\"Fase actual: {lavadero_error4.fase}\") lavadero_error4.avanzarFase() print(f\"Fase final: {lavadero_error4.fase}\") \"\"\" # EJEMPLO ERROR 5: Fase incorrecta tras rodillos (con secado a mano y encerado) (Requisito 13) \"\"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 5: La fase de encerado nunca se ejecuta\") lavadero_error5 = Lavadero() # Lavado con secado a mano y encerado lavadero_error5.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=True) # Avanzamos fases y mostramos todas while lavadero_error5.ocupado: print(f\"Fase actual: {lavadero_error5.fase}\") lavadero_error5.avanzarFase() print(f\"Fase final: {lavadero_error5.fase}\") \"\"\" \"\"\" # EJEMPLO ERROR 6: Uso de atributo inexistente self.lavadero print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 6: Uso de atributo inexistente self.lavadero\") lavadero_error6 = Lavadero() # Llamamos al m\u00e9todo de prueba lavadero_error6.ejecutar_y_obtener_fases(prelavado=False, secado=False, encerado=False) \"\"\" lavadero.py: # lavadero.py class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" # A continuaci\u00f3n, las constantes, que ser\u00e1n las diferentes fases del lavadero. # El uso de estas constantes mejora la legibilidad y el mantenimiento del c\u00f3digo. FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 # Tenemos el constructor de la clase. Encargado de inicializar el lavaderio. # Podemos ver tambi\u00e9n los atributos privados del lavadero. def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() # Propiedades. Nos permiten acceder a los atributos privados de forma controlada. @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado # M\u00e9todos principales. # Las dos siguientes funciones sirven para controlar el ciclo de lavado. def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" # Condiciones. if self.__ocupado: raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado # Ingresos def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.00 if self.__encerado: coste_lavado += 1.00 self.__ingresos += coste_lavado return coste_lavado # Avance de las fases. # Se implementa la l\u00f3gica de avance de fases del lavadero. def avanzarFase(self): if not self.__ocupado: return if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO else: self.__fase = self.FASE_SECADO_AUTOMATICO elif self.__fase == self.FASE_SECADO_MANO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") # Muestra por pantalla. # Se muesteran por pantalla la fase actual y el estado del lavadero. def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # Pruebas unitarias # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self._hacer_lavado(prelavado, secado, encerado) fases_visitadas = [self.fase] while self.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.avanzarFase() fases_visitadas.append(self.fase) return fases_visitadas","title":"2. C\u00f3digo corregido"},{"location":"elementos_python/","text":"Elementos de Python En este apartado explico las funciones de los dos archivos que construyen el programa e incluyo dos enlaces correspondientes a dos cuadernos de Jupyter Notebook en los que muestro el c\u00f3digo comentado de la aplicaci\u00f3n Lavadero y de la capa de ejecuci\u00f3n mainapp . \u00a1IMPORTANTE! En este apartado, el c\u00f3digo est\u00e1 comentado, con el objetivo de ir entendiendo las diferentes fases del programa y c\u00f3mo funciona, sin errores en el c\u00f3digo corregidos. Los errores est\u00e1n corregidos en Ejecuci\u00f3n y Depuraci\u00f3n . 1. Funciones de los archivos main_app.py: Este archivo es el \"controlador\" del lavadero. Sirve para iniciar el lavadero, decidir los ejemplos que se prueban, mostrar los resultados por pantalla... Se tiene que ejecutar y decide qu\u00e9 pasa y cu\u00e1ndo. lavadero.py: Este archivo sirve para controlar los estados y fases del lavadero, calcular precios, llevar los ingresos... No se ejecuta solo, ni imprime ejemplos ni decide el flujo principal, solo responde cuando se le llama. 2. C\u00f3digo comentado - Jupyter Notebook Descargar notebook lavadero.ipynb Descargar notebook main_app.ipynb 3. Realizaci\u00f3n A continuaci\u00f3n adjunto capturas de pantalla en las que muestro la autor\u00eda de estos dos cuadernos: En primer lugar, lavadero.py En segundo lugar, main_app.py","title":"2. Elementos de Python"},{"location":"elementos_python/#elementos-de-python","text":"En este apartado explico las funciones de los dos archivos que construyen el programa e incluyo dos enlaces correspondientes a dos cuadernos de Jupyter Notebook en los que muestro el c\u00f3digo comentado de la aplicaci\u00f3n Lavadero y de la capa de ejecuci\u00f3n mainapp . \u00a1IMPORTANTE! En este apartado, el c\u00f3digo est\u00e1 comentado, con el objetivo de ir entendiendo las diferentes fases del programa y c\u00f3mo funciona, sin errores en el c\u00f3digo corregidos. Los errores est\u00e1n corregidos en Ejecuci\u00f3n y Depuraci\u00f3n .","title":"Elementos de Python"},{"location":"elementos_python/#1-funciones-de-los-archivos","text":"main_app.py: Este archivo es el \"controlador\" del lavadero. Sirve para iniciar el lavadero, decidir los ejemplos que se prueban, mostrar los resultados por pantalla... Se tiene que ejecutar y decide qu\u00e9 pasa y cu\u00e1ndo. lavadero.py: Este archivo sirve para controlar los estados y fases del lavadero, calcular precios, llevar los ingresos... No se ejecuta solo, ni imprime ejemplos ni decide el flujo principal, solo responde cuando se le llama.","title":"1. Funciones de los archivos"},{"location":"elementos_python/#2-codigo-comentado-jupyter-notebook","text":"Descargar notebook lavadero.ipynb Descargar notebook main_app.ipynb","title":"2. C\u00f3digo comentado - Jupyter Notebook"},{"location":"elementos_python/#3-realizacion","text":"A continuaci\u00f3n adjunto capturas de pantalla en las que muestro la autor\u00eda de estos dos cuadernos: En primer lugar, lavadero.py En segundo lugar, main_app.py","title":"3. Realizaci\u00f3n"},{"location":"pruebas/","text":"Pruebas En este apartado muestro, en orden, la realizaci\u00f3n de los diferentes tests y su ejecuci\u00f3n. Tambi\u00e9n se muestra la correcci\u00f3n de errores de aquellos que los contengan. 1. Tests Tests 1: Cuando se crea un lavadero, \u00e9ste no tiene ingresos, no est\u00e1 ocupado, est\u00e1 en fase 0 y todas las opciones de lavado (prelavado a mano, secado a mano y encerado) est\u00e1n puestas a false. Errores: Este test no muestra errores. Test 2: Cuando se intenta comprar un lavado con encerado pero sin secado a mano, se produce una ValueError. Errores: El test intenta llamar a _hacer_lavado, pero este m\u00e9todo no existe en la clase Lavadero. AttributeError: 'Lavadero' object has no attribute '_hacer_lavado' Did you mean: 'hacerLavado'? Soluci\u00f3n: A\u00f1adir _hacer_lavado a lavadero.py Ejecuci\u00f3n tras solucionar error: Test 3: Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una ValueError. Errores: El enunciado dice ValueError, no RuntimeError. if self.__ocupado: raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") Soluci\u00f3n: Cambiar el tipo de excepci\u00f3n. Ejecici\u00f3n tras soluiconar el error: solucionado test3 Tests 4: Si seleccionamos un lavado con prelavado a mano, los ingresos de lavadero son 6,50\u20ac Errores: Este test no muestra errores. Test 5: Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac. Errores: El coste del lavado est\u00e1 a 1.20, por lo que 5.00 + 1.20 = 6.20. if self.__secado_a_mano: coste_lavado += 1.20 Soluci\u00f3n: Cambiar el precio del secado a mano. Ejecuci\u00f3n tras soluiconar el error: solucionado test5 Test 6: Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac. Errores: El coste del encerado tiene que ser 1.20\u20ac, no 1.00\u20ac if self.__encerado: coste_lavado += 1.20 Soluci\u00f3n: Cambiar el precio del secado a mano. Ejecuci\u00f3n tras soluiconar el error: solucionado test6 Test 7: Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac. Errores: Este test no muestra errores. Test 8: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac. Errores: Este test no muestra errores. Test 9: Si seleccionamos un lavado sin extras y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 6, 0. Errores: El m\u00e9todo avanzarFase continuaba evaluando estados tras finalizar el lavado. No se retorna. elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO else: self.__fase = self.FASE_SECADO_AUTOMATICO elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() return elif self.__fase == self.FASE_SECADO_MANO: self.terminar() return elif self.__fase == self.FASE_ENCERADO: self.terminar() return Soluci\u00f3n: A\u00f1adir return tras terminar() Ejecuci\u00f3n tras soluiconar el error: solucionado test9 Test 10: Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0. Errores: Este test no muestra errores. Test 11: Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por l> Errores: Este test no muestra errores. Test 12: Si seleccionamos un lavado con secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0. Errores: La fase 8 (encerado) est\u00e1 siendo saltada. elif self.__fase == self.FASE_SECADO_MANO: self.terminar() return Soluci\u00f3n: Ejecuci\u00f3n tras soluiconar el error: solucionado test12 Test 13: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. Errores: Este test no muestra errores. Test 14: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0 Errores: Este test no muestra errores. 2. C\u00f3digo corregido Muestro el c\u00f3digo completo corregido como resultado de este apartado: lavadero.py # lavadero.py class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" if self.__ocupado: raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado def _hacer_lavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" M\u00e9todo interno utilizado para pruebas unitarias. Aplica las mismas reglas de negocio que hacerLavado. \"\"\" self.hacerLavado(prelavado_a_mano, secado_a_mano, encerado) def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.00 if self.__encerado: coste_lavado += 1.20 self.__ingresos += coste_lavado return coste_lavado def avanzarFase(self): if not self.__ocupado: return if self.__fase == self.FASE_INACTIVO: self._cobrar() self.__fase = self.FASE_COBRANDO elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO else: self.__fase = self.FASE_SECADO_AUTOMATICO elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() return elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO else: self.terminar() return elif self.__fase == self.FASE_ENCERADO: self.terminar() return else: raise RuntimeError( f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\" ) def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self._hacer_lavado(prelavado, secado, encerado) fases_visitadas = [self.fase] while self.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.avanzarFase() fases_visitadas.append(self.fase) return fases_visitadas test_lavadero_unittest.py: # tests/test_lavadero_unittest.py import unittest # Importamos la clase Lavadero desde el m\u00f3dulo padre from src.lavadero import Lavadero class TestLavadero(unittest.TestCase): # M\u00e9todo que se ejecuta antes de cada test. # Es el equivalente del @pytest.fixture en este contexto. def setUp(self): \"\"\"Prepara una nueva instancia de Lavadero antes de cada prueba.\"\"\" self.lavadero = Lavadero() # ---------------------------------------------------------------------- # Funci\u00f3n para resetear el estado cuanto terminamos una ejecuci\u00f3n de lavado # ---------------------------------------------------------------------- \"\"\" def test_reseteo_estado_con_terminar(self): #Test 4: Verifica terminar() resetea todas las flags y el estado. self.lavadero._hacer_lavado(True, True, True) self.lavadero._cobrar() self.lavadero.terminar() self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertTrue(self.lavadero.ingresos > 0) # Los ingresos deben mantenerse \"\"\" # ---------------------------------------------------------------------- # TESTS # ---------------------------------------------------------------------- # Test 1. Cuando se crea un lavadero, \u00e9ste no tiene ingresos, no est\u00e1 ocupado, est\u00e1 en fase 0 y todas las opciones de lavado (prelavado a mano, secado a mano y encerado) est\u00e1n puestas a false. \"\"\" def test1_estado_inicial_correcto(self): # Test 1: Verifica que el estado inicial es Inactivo y con 0 ingresos. self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) # Fase inicial self.assertEqual(self.lavadero.ingresos, 0.0) # Ingresos iniciales self.assertFalse(self.lavadero.ocupado) # No est\u00e1 ocupadoS # Opciones de lavado iniciales a false. self.assertFalse(self.lavadero.prelavado_a_mano) self.assertFalse(self.lavadero.secado_a_mano) self.assertFalse(self.lavadero.encerado) \"\"\" # Test 2. Cuando se intenta comprar un lavado con encerado pero sin secado a mano, se produce una ValueError. \"\"\" def test2_excepcion_encerado_sin_secado(self): #Test 2: Comprueba que encerar sin secado a mano lanza ValueError. # _hacer_lavado: (Prelavado: False, Secado a mano: False, Encerado: True) with self.assertRaises(ValueError): self.lavadero._hacer_lavado(False, False, True) \"\"\" # Test 3. Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una ValueError. \"\"\" def test3_excepcion_lavado_mientras_otro_en_marcha(self): # Test 3: Comprueba que no se puede iniciar un lavado si ya hay otro en marcha # Primer lavado v\u00e1lido self.lavadero._hacer_lavado(False, False, False) # Segundo lavado mientras el primero sigue activo \u2192 ValueError with self.assertRaises(ValueError): self.lavadero._hacer_lavado(False, False, False) \"\"\" # Test 4. Si seleccionamos un lavado con prelavado a mano, los ingresos de lavadero son 6,50\u20ac. \"\"\" def test4_ingresos_prelavado_a_mano(self): # Test 4: Comprueba que un lavado con prelavado a mano cuesta 6,50 \u20ac # _hacer_lavado: (Prelavado: True, Secado a mano: False, Encerado: False) self.lavadero._hacer_lavado(True, False, False) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 6.50) \"\"\" # Test 5. Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac. \"\"\" def test5_ingresos_secado_a_mano(self): # Test 5: Comprueba que un lavado con secado a mano cuesta 6,00 \u20ac # _hacer_lavado: (Prelavado: False, Secado a mano: True, Encerado: False) self.lavadero._hacer_lavado(False, True, False) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 6.00) \"\"\" # Test 6. Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac. \"\"\" def test6_ingresos_secado_mano_y_encerado(self): # Test 6: Comprueba que un lavado con secado a mano y encerado cuesta 7,20 \u20ac # _hacer_lavado: (Prelavado: False, Secado a mano: True, Encerado: True) self.lavadero._hacer_lavado(False, True, True) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 7.20) \"\"\" # Test 7. Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac. \"\"\" def test7_ingresos_prelavado_y_secado_mano(self): # Test 7: Comprueba que un lavado con prelavado a mano y secado a mano cuesta 7,50 \u20ac # _hacer_lavado: (Prelavado: True, Secado a mano: True, Encerado: False) self.lavadero._hacer_lavado(True, True, False) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 7.50) \"\"\" # Test 8. Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac. \"\"\" def test8_ingresos_prelavado_secado_y_encerado(self): # Test 8: Comprueba que un lavado con prelavado a mano, secado a mano y encerado cuesta 8,70 \u20ac # _hacer_lavado: (Prelavado: True, Secado a mano: True, Encerado: True) self.lavadero._hacer_lavado(True, True, True) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 8.70) \"\"\" # ---------------------------------------------------------------------- # Tests de flujo de fases # Utilizamos la funci\u00f3n def ejecutar_y_obtener_fases(self, prelavado, secado, encerado) # Estos tests dan errores ya que en el c\u00f3digo original hay errores en las las fases esperados, en los saltos. # ---------------------------------------------------------------------- # Test 9. Si seleccionamos un lavado sin extras y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 6, 0. \"\"\" def test9_flujo_rapido_sin_extras(self): #Test 9: Simula el flujo r\u00e1pido sin opciones opcionales. fases_esperadas = [0, 1, 3, 4, 5, 6, 0] # Ejecutar el ciclo completo y obtener las fases fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(prelavado=False, secado=False, encerado=False) # Verificar que las fases obtenidas coinciden con las esperadas self.assertEqual(fases_obtenidas, fases_esperadas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\") \"\"\" # Test 10. Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0. \"\"\" def test10_flujo_con_prelavado(self): #Test 10: Flujo de fases para un lavado con prelavado a mano. fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=False, encerado=False ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) \"\"\" # Test 11. Si seleccionamos un lavado con secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 0. \"\"\" def test11_flujo_con_secado_mano(self): fases_esperadas = [0, 1, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=False, secado=True, encerado=False ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Esperadas: {fases_esperadas} | Obtenidas: {fases_obtenidas}\" ) \"\"\" # Test 12. Si seleccionamos un lavado con secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0. \"\"\" def test12_flujo_con_secado_mano_y_encerado(self): Test 12: Si seleccionamos un lavado con secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0. fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=False, secado=True, encerado=True ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) \"\"\" # Test 13. Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. \"\"\" def test14_flujo_prelavado_y_secado_mano(self): fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=True, encerado=False ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) \"\"\" # Test 14. Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. def test15_flujo_prelavado_secado_y_encerado(self): \"\"\" Test 15: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. \"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=True, encerado=True ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) # Bloque de ejecuci\u00f3n para ejecutar los tests si el archivo es corrido directamente if __name__ == '__main__': unittest.main() main_app.py: # main_app.py # Importar la clase desde el otro archivo (m\u00f3dulo) from lavadero import Lavadero # MODIFICACI\u00d3N CLAVE AQU\u00cd: La funci\u00f3n ahora acepta 3 argumentos def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado): \"\"\" Simula el proceso de lavado para un veh\u00edculo con las opciones dadas. Ahora acepta una instancia de lavadero. :param lavadero: Instancia de Lavadero. :param prelavado: bool, True si se solicita prelavado a mano. :param secado_mano: bool, True si se solicita secado a mano. :param encerado: bool, True si se solicita encerado. \"\"\" print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\") # Mostrar las opciones solicitadas print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\") # 1. Iniciar el lavado try: # Esto establece las opciones y pasa a Fase 0 (Inactivo, pero Ocupado=True) lavadero.hacerLavado(prelavado, secado_mano, encerado) print(\"\\nCoche entra. Estado inicial:\") lavadero.imprimir_estado() # 2. Avanza por las fases print(\"\\nAVANZANDO FASE POR FASE:\") # Usamos un contador para evitar bucles infinitos en caso de error o bucles inesperados pasos = 0 while lavadero.ocupado and pasos < 20: # El cobro ahora ocurre en la primera llamada a avanzarFase (transici\u00f3n 0 -> 1) lavadero.avanzarFase() print(f\"-> Fase actual: \", end=\"\") lavadero.imprimir_fase() print() pasos += 1 print(\"\\n----------------------------------------\") print(\"Lavado completo. Estado final:\") lavadero.imprimir_estado() print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\") print(\"----------------------------------------\") except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2) print(f\"ERROR DE ARGUMENTO: {e}\") except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3) print(f\"ERROR DE ESTADO: {e}\") except Exception as e: print(f\"ERROR INESPERADO: {e}\") # Punto de entrada (main): Aqu\u00ed pasamos los par\u00e1metros if __name__ == \"__main__\": lavadero_global = Lavadero() # Usamos una \u00fanica instancia para acumular ingresos \"\"\"\" # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14) # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True) # EJEMPLO 2: Lavado r\u00e1pido sin extras (Requisito 9) # Precio esperado: 5.00 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False) # EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2) print(\"\\n=======================================================\") print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True) # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 2: Intentar iniciar un lavado estando ocupado\") \"\"\" # EJEMPLO ERROR 2: Intentar iniciar un lavado estando ocupado (Requisito 3) \"\"\" lavadero_error = Lavadero() try: # Primer lavado (arranca correctamente) lavadero_error.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) print(\"Primer lavado iniciado correctamente\") # Segundo lavado SIN terminar el primero lavadero_error.hacerLavado(prelavado_a_mano=True, secado_a_mano=False, encerado=False) except Exception as e: print(f\"EXCEPCI\u00d3N CAPTURADA: {type(e).__name__} -> {e}\") # Esperado: RuntimeError \"\"\" # EJEMPLO ERROR 3: Precio incorrecto del secado a mano (Requisito 7) \"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 3: Precio incorrecto del secado a mano\") lavadero_error3 = Lavadero() # Lavado SOLO con secado a mano lavadero_error3.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=False) # Avanzamos SOLO UNA FASE para que se cobre lavadero_error3.avanzarFase() print(f\"Ingresos tras el cobro: {lavadero_error3.ingresos:.2f} \u20ac\") \"\"\" # EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano) (Requisito 13) \"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano)\") lavadero_error4 = Lavadero() # Lavado SIN secado a mano lavadero_error4.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) # Avanzamos fases manualmente while lavadero_error4.ocupado: print(f\"Fase actual: {lavadero_error4.fase}\") lavadero_error4.avanzarFase() print(f\"Fase final: {lavadero_error4.fase}\") \"\"\" # EJEMPLO ERROR 5: Fase incorrecta tras rodillos (con secado a mano y encerado) (Requisito 13) \"\"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 5: La fase de encerado nunca se ejecuta\") lavadero_error5 = Lavadero() # Lavado con secado a mano y encerado lavadero_error5.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=True) # Avanzamos fases y mostramos todas while lavadero_error5.ocupado: print(f\"Fase actual: {lavadero_error5.fase}\") lavadero_error5.avanzarFase() print(f\"Fase final: {lavadero_error5.fase}\") \"\"\" \"\"\" # EJEMPLO ERROR 6: Uso de atributo inexistente self.lavadero print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 6: Uso de atributo inexistente self.lavadero\") lavadero_error6 = Lavadero() # Llamamos al m\u00e9todo de prueba lavadero_error6.ejecutar_y_obtener_fases(prelavado=False, secado=False, encerado=False) \"\"\"","title":"4. Pruebas"},{"location":"pruebas/#pruebas","text":"En este apartado muestro, en orden, la realizaci\u00f3n de los diferentes tests y su ejecuci\u00f3n. Tambi\u00e9n se muestra la correcci\u00f3n de errores de aquellos que los contengan.","title":"Pruebas"},{"location":"pruebas/#1-tests","text":"Tests 1: Cuando se crea un lavadero, \u00e9ste no tiene ingresos, no est\u00e1 ocupado, est\u00e1 en fase 0 y todas las opciones de lavado (prelavado a mano, secado a mano y encerado) est\u00e1n puestas a false. Errores: Este test no muestra errores. Test 2: Cuando se intenta comprar un lavado con encerado pero sin secado a mano, se produce una ValueError. Errores: El test intenta llamar a _hacer_lavado, pero este m\u00e9todo no existe en la clase Lavadero. AttributeError: 'Lavadero' object has no attribute '_hacer_lavado' Did you mean: 'hacerLavado'? Soluci\u00f3n: A\u00f1adir _hacer_lavado a lavadero.py Ejecuci\u00f3n tras solucionar error: Test 3: Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una ValueError. Errores: El enunciado dice ValueError, no RuntimeError. if self.__ocupado: raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") Soluci\u00f3n: Cambiar el tipo de excepci\u00f3n. Ejecici\u00f3n tras soluiconar el error: solucionado test3 Tests 4: Si seleccionamos un lavado con prelavado a mano, los ingresos de lavadero son 6,50\u20ac Errores: Este test no muestra errores. Test 5: Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac. Errores: El coste del lavado est\u00e1 a 1.20, por lo que 5.00 + 1.20 = 6.20. if self.__secado_a_mano: coste_lavado += 1.20 Soluci\u00f3n: Cambiar el precio del secado a mano. Ejecuci\u00f3n tras soluiconar el error: solucionado test5 Test 6: Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac. Errores: El coste del encerado tiene que ser 1.20\u20ac, no 1.00\u20ac if self.__encerado: coste_lavado += 1.20 Soluci\u00f3n: Cambiar el precio del secado a mano. Ejecuci\u00f3n tras soluiconar el error: solucionado test6 Test 7: Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac. Errores: Este test no muestra errores. Test 8: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac. Errores: Este test no muestra errores. Test 9: Si seleccionamos un lavado sin extras y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 6, 0. Errores: El m\u00e9todo avanzarFase continuaba evaluando estados tras finalizar el lavado. No se retorna. elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO else: self.__fase = self.FASE_SECADO_AUTOMATICO elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() return elif self.__fase == self.FASE_SECADO_MANO: self.terminar() return elif self.__fase == self.FASE_ENCERADO: self.terminar() return Soluci\u00f3n: A\u00f1adir return tras terminar() Ejecuci\u00f3n tras soluiconar el error: solucionado test9 Test 10: Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0. Errores: Este test no muestra errores. Test 11: Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por l> Errores: Este test no muestra errores. Test 12: Si seleccionamos un lavado con secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0. Errores: La fase 8 (encerado) est\u00e1 siendo saltada. elif self.__fase == self.FASE_SECADO_MANO: self.terminar() return Soluci\u00f3n: Ejecuci\u00f3n tras soluiconar el error: solucionado test12 Test 13: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. Errores: Este test no muestra errores. Test 14: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0 Errores: Este test no muestra errores.","title":"1. Tests"},{"location":"pruebas/#2-codigo-corregido","text":"Muestro el c\u00f3digo completo corregido como resultado de este apartado: lavadero.py # lavadero.py class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" if self.__ocupado: raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado def _hacer_lavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" M\u00e9todo interno utilizado para pruebas unitarias. Aplica las mismas reglas de negocio que hacerLavado. \"\"\" self.hacerLavado(prelavado_a_mano, secado_a_mano, encerado) def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.00 if self.__encerado: coste_lavado += 1.20 self.__ingresos += coste_lavado return coste_lavado def avanzarFase(self): if not self.__ocupado: return if self.__fase == self.FASE_INACTIVO: self._cobrar() self.__fase = self.FASE_COBRANDO elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO else: self.__fase = self.FASE_SECADO_AUTOMATICO elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() return elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO else: self.terminar() return elif self.__fase == self.FASE_ENCERADO: self.terminar() return else: raise RuntimeError( f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\" ) def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self._hacer_lavado(prelavado, secado, encerado) fases_visitadas = [self.fase] while self.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.avanzarFase() fases_visitadas.append(self.fase) return fases_visitadas test_lavadero_unittest.py: # tests/test_lavadero_unittest.py import unittest # Importamos la clase Lavadero desde el m\u00f3dulo padre from src.lavadero import Lavadero class TestLavadero(unittest.TestCase): # M\u00e9todo que se ejecuta antes de cada test. # Es el equivalente del @pytest.fixture en este contexto. def setUp(self): \"\"\"Prepara una nueva instancia de Lavadero antes de cada prueba.\"\"\" self.lavadero = Lavadero() # ---------------------------------------------------------------------- # Funci\u00f3n para resetear el estado cuanto terminamos una ejecuci\u00f3n de lavado # ---------------------------------------------------------------------- \"\"\" def test_reseteo_estado_con_terminar(self): #Test 4: Verifica terminar() resetea todas las flags y el estado. self.lavadero._hacer_lavado(True, True, True) self.lavadero._cobrar() self.lavadero.terminar() self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertTrue(self.lavadero.ingresos > 0) # Los ingresos deben mantenerse \"\"\" # ---------------------------------------------------------------------- # TESTS # ---------------------------------------------------------------------- # Test 1. Cuando se crea un lavadero, \u00e9ste no tiene ingresos, no est\u00e1 ocupado, est\u00e1 en fase 0 y todas las opciones de lavado (prelavado a mano, secado a mano y encerado) est\u00e1n puestas a false. \"\"\" def test1_estado_inicial_correcto(self): # Test 1: Verifica que el estado inicial es Inactivo y con 0 ingresos. self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) # Fase inicial self.assertEqual(self.lavadero.ingresos, 0.0) # Ingresos iniciales self.assertFalse(self.lavadero.ocupado) # No est\u00e1 ocupadoS # Opciones de lavado iniciales a false. self.assertFalse(self.lavadero.prelavado_a_mano) self.assertFalse(self.lavadero.secado_a_mano) self.assertFalse(self.lavadero.encerado) \"\"\" # Test 2. Cuando se intenta comprar un lavado con encerado pero sin secado a mano, se produce una ValueError. \"\"\" def test2_excepcion_encerado_sin_secado(self): #Test 2: Comprueba que encerar sin secado a mano lanza ValueError. # _hacer_lavado: (Prelavado: False, Secado a mano: False, Encerado: True) with self.assertRaises(ValueError): self.lavadero._hacer_lavado(False, False, True) \"\"\" # Test 3. Cuando se intenta hacer un lavado mientras que otro ya est\u00e1 en marcha, se produce una ValueError. \"\"\" def test3_excepcion_lavado_mientras_otro_en_marcha(self): # Test 3: Comprueba que no se puede iniciar un lavado si ya hay otro en marcha # Primer lavado v\u00e1lido self.lavadero._hacer_lavado(False, False, False) # Segundo lavado mientras el primero sigue activo \u2192 ValueError with self.assertRaises(ValueError): self.lavadero._hacer_lavado(False, False, False) \"\"\" # Test 4. Si seleccionamos un lavado con prelavado a mano, los ingresos de lavadero son 6,50\u20ac. \"\"\" def test4_ingresos_prelavado_a_mano(self): # Test 4: Comprueba que un lavado con prelavado a mano cuesta 6,50 \u20ac # _hacer_lavado: (Prelavado: True, Secado a mano: False, Encerado: False) self.lavadero._hacer_lavado(True, False, False) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 6.50) \"\"\" # Test 5. Si seleccionamos un lavado con secado a mano, los ingresos son 6,00\u20ac. \"\"\" def test5_ingresos_secado_a_mano(self): # Test 5: Comprueba que un lavado con secado a mano cuesta 6,00 \u20ac # _hacer_lavado: (Prelavado: False, Secado a mano: True, Encerado: False) self.lavadero._hacer_lavado(False, True, False) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 6.00) \"\"\" # Test 6. Si seleccionamos un lavado con secado a mano y encerado, los ingresos son 7,20\u20ac. \"\"\" def test6_ingresos_secado_mano_y_encerado(self): # Test 6: Comprueba que un lavado con secado a mano y encerado cuesta 7,20 \u20ac # _hacer_lavado: (Prelavado: False, Secado a mano: True, Encerado: True) self.lavadero._hacer_lavado(False, True, True) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 7.20) \"\"\" # Test 7. Si seleccionamos un lavado con prelavado a mano y secado a mano, los ingresos son 7,50\u20ac. \"\"\" def test7_ingresos_prelavado_y_secado_mano(self): # Test 7: Comprueba que un lavado con prelavado a mano y secado a mano cuesta 7,50 \u20ac # _hacer_lavado: (Prelavado: True, Secado a mano: True, Encerado: False) self.lavadero._hacer_lavado(True, True, False) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 7.50) \"\"\" # Test 8. Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, los ingresos son 8,70\u20ac. \"\"\" def test8_ingresos_prelavado_secado_y_encerado(self): # Test 8: Comprueba que un lavado con prelavado a mano, secado a mano y encerado cuesta 8,70 \u20ac # _hacer_lavado: (Prelavado: True, Secado a mano: True, Encerado: True) self.lavadero._hacer_lavado(True, True, True) # Avanzamos una fase para que se realice el cobro self.lavadero.avanzarFase() self.assertEqual(self.lavadero.ingresos, 8.70) \"\"\" # ---------------------------------------------------------------------- # Tests de flujo de fases # Utilizamos la funci\u00f3n def ejecutar_y_obtener_fases(self, prelavado, secado, encerado) # Estos tests dan errores ya que en el c\u00f3digo original hay errores en las las fases esperados, en los saltos. # ---------------------------------------------------------------------- # Test 9. Si seleccionamos un lavado sin extras y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 6, 0. \"\"\" def test9_flujo_rapido_sin_extras(self): #Test 9: Simula el flujo r\u00e1pido sin opciones opcionales. fases_esperadas = [0, 1, 3, 4, 5, 6, 0] # Ejecutar el ciclo completo y obtener las fases fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(prelavado=False, secado=False, encerado=False) # Verificar que las fases obtenidas coinciden con las esperadas self.assertEqual(fases_obtenidas, fases_esperadas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\") \"\"\" # Test 10. Si seleccionamos un lavado con prelavado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 6, 0. \"\"\" def test10_flujo_con_prelavado(self): #Test 10: Flujo de fases para un lavado con prelavado a mano. fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=False, encerado=False ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) \"\"\" # Test 11. Si seleccionamos un lavado con secado a mano y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 0. \"\"\" def test11_flujo_con_secado_mano(self): fases_esperadas = [0, 1, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=False, secado=True, encerado=False ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Esperadas: {fases_esperadas} | Obtenidas: {fases_obtenidas}\" ) \"\"\" # Test 12. Si seleccionamos un lavado con secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0. \"\"\" def test12_flujo_con_secado_mano_y_encerado(self): Test 12: Si seleccionamos un lavado con secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 3, 4, 5, 7, 8, 0. fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=False, secado=True, encerado=True ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) \"\"\" # Test 13. Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. \"\"\" def test14_flujo_prelavado_y_secado_mano(self): fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=True, encerado=False ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) \"\"\" # Test 14. Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado, y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. def test15_flujo_prelavado_secado_y_encerado(self): \"\"\" Test 15: Si seleccionamos un lavado con prelavado a mano, secado a mano y encerado y vamos avanzando fases, el lavadero pasa por las fases 0, 1, 2, 3, 4, 5, 7, 8, 0. \"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases( prelavado=True, secado=True, encerado=True ) self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\" ) # Bloque de ejecuci\u00f3n para ejecutar los tests si el archivo es corrido directamente if __name__ == '__main__': unittest.main() main_app.py: # main_app.py # Importar la clase desde el otro archivo (m\u00f3dulo) from lavadero import Lavadero # MODIFICACI\u00d3N CLAVE AQU\u00cd: La funci\u00f3n ahora acepta 3 argumentos def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado): \"\"\" Simula el proceso de lavado para un veh\u00edculo con las opciones dadas. Ahora acepta una instancia de lavadero. :param lavadero: Instancia de Lavadero. :param prelavado: bool, True si se solicita prelavado a mano. :param secado_mano: bool, True si se solicita secado a mano. :param encerado: bool, True si se solicita encerado. \"\"\" print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\") # Mostrar las opciones solicitadas print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\") # 1. Iniciar el lavado try: # Esto establece las opciones y pasa a Fase 0 (Inactivo, pero Ocupado=True) lavadero.hacerLavado(prelavado, secado_mano, encerado) print(\"\\nCoche entra. Estado inicial:\") lavadero.imprimir_estado() # 2. Avanza por las fases print(\"\\nAVANZANDO FASE POR FASE:\") # Usamos un contador para evitar bucles infinitos en caso de error o bucles inesperados pasos = 0 while lavadero.ocupado and pasos < 20: # El cobro ahora ocurre en la primera llamada a avanzarFase (transici\u00f3n 0 -> 1) lavadero.avanzarFase() print(f\"-> Fase actual: \", end=\"\") lavadero.imprimir_fase() print() pasos += 1 print(\"\\n----------------------------------------\") print(\"Lavado completo. Estado final:\") lavadero.imprimir_estado() print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\") print(\"----------------------------------------\") except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2) print(f\"ERROR DE ARGUMENTO: {e}\") except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3) print(f\"ERROR DE ESTADO: {e}\") except Exception as e: print(f\"ERROR INESPERADO: {e}\") # Punto de entrada (main): Aqu\u00ed pasamos los par\u00e1metros if __name__ == \"__main__\": lavadero_global = Lavadero() # Usamos una \u00fanica instancia para acumular ingresos \"\"\"\" # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14) # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True) # EJEMPLO 2: Lavado r\u00e1pido sin extras (Requisito 9) # Precio esperado: 5.00 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False) # EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2) print(\"\\n=======================================================\") print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True) # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 2: Intentar iniciar un lavado estando ocupado\") \"\"\" # EJEMPLO ERROR 2: Intentar iniciar un lavado estando ocupado (Requisito 3) \"\"\" lavadero_error = Lavadero() try: # Primer lavado (arranca correctamente) lavadero_error.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) print(\"Primer lavado iniciado correctamente\") # Segundo lavado SIN terminar el primero lavadero_error.hacerLavado(prelavado_a_mano=True, secado_a_mano=False, encerado=False) except Exception as e: print(f\"EXCEPCI\u00d3N CAPTURADA: {type(e).__name__} -> {e}\") # Esperado: RuntimeError \"\"\" # EJEMPLO ERROR 3: Precio incorrecto del secado a mano (Requisito 7) \"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 3: Precio incorrecto del secado a mano\") lavadero_error3 = Lavadero() # Lavado SOLO con secado a mano lavadero_error3.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=False) # Avanzamos SOLO UNA FASE para que se cobre lavadero_error3.avanzarFase() print(f\"Ingresos tras el cobro: {lavadero_error3.ingresos:.2f} \u20ac\") \"\"\" # EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano) (Requisito 13) \"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 4: Fase incorrecta tras rodillos (sin secado a mano)\") lavadero_error4 = Lavadero() # Lavado SIN secado a mano lavadero_error4.hacerLavado(prelavado_a_mano=False, secado_a_mano=False, encerado=False) # Avanzamos fases manualmente while lavadero_error4.ocupado: print(f\"Fase actual: {lavadero_error4.fase}\") lavadero_error4.avanzarFase() print(f\"Fase final: {lavadero_error4.fase}\") \"\"\" # EJEMPLO ERROR 5: Fase incorrecta tras rodillos (con secado a mano y encerado) (Requisito 13) \"\"\"\" print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 5: La fase de encerado nunca se ejecuta\") lavadero_error5 = Lavadero() # Lavado con secado a mano y encerado lavadero_error5.hacerLavado(prelavado_a_mano=False, secado_a_mano=True, encerado=True) # Avanzamos fases y mostramos todas while lavadero_error5.ocupado: print(f\"Fase actual: {lavadero_error5.fase}\") lavadero_error5.avanzarFase() print(f\"Fase final: {lavadero_error5.fase}\") \"\"\" \"\"\" # EJEMPLO ERROR 6: Uso de atributo inexistente self.lavadero print(\"\\n=======================================================\") print(\"EJEMPLO ERROR 6: Uso de atributo inexistente self.lavadero\") lavadero_error6 = Lavadero() # Llamamos al m\u00e9todo de prueba lavadero_error6.ejecutar_y_obtener_fases(prelavado=False, secado=False, encerado=False) \"\"\"","title":"2. C\u00f3digo corregido"},{"location":"reflexion/","text":"Reflexi\u00f3n sobre comparaci\u00f3n de la infraestructura de seguridad de los lenguajes Tras haber visto los contenidos de esta unidad, me he dado cuenta de que la seguridad en la programaci\u00f3n es algo mucho m\u00e1s amplio de lo que pensaba en un principio. Cre\u00eda que bastaba con usar un lenguaje \u201cseguro\u201d, estandarizado y digamos, \"popular\". Pero ahora entiendo que la seguridad depende de muchos factores como el lenguaje, el entorno donde se ejecuta el programa y las medidas de protecci\u00f3n adicionales que se utilicen. Me ha parecido interesante comparar lenguajes como Python y Java . Creo que Python es muy c\u00f3modo para programar y evita muchos errores comunes, como los relacionados con la memoria, lo que lo hace bastante seguro. Sin embargo, tambi\u00e9n he visto que Python no tiene un sistema de seguridad tan estricto integrado, por lo que si alguien consigue ejecutar c\u00f3digo malicioso, puede causar bastantes problemas en el sistema. Por otro lado, creo que lenguajes como Java o .NET est\u00e1n m\u00e1s enfocados a la seguridad. Incorporan controles como la verificaci\u00f3n del c\u00f3digo, la gesti\u00f3n de permisos y la separaci\u00f3n de privilegios, lo que permite ejecutar aplicaciones de forma m\u00e1s controlada. Aunque puedan ser algo m\u00e1s complejos, ofrecen un mayor nivel de protecci\u00f3n, sobre todo en aplicaciones grandes o cr\u00edticas. Tambi\u00e9n me ha llamado mucho la atenci\u00f3n el concepto de sandboxing . Herramientas como Firejail o Docker permiten ejecutar programas de forma aislada, evitando que afecten al resto del sistema. Esto me parece muy \u00fatil, tanto para probar software como para proteger el equipo frente a posibles amenazas. Como conclusi\u00f3n, esta unidad me ha servido para entender que la seguridad no depende de una sola cosa, sino de aplicar varias capas de protecci\u00f3n. Elegir bien el lenguaje, programar de forma correcta y usar entornos aislados cuando sea necesario es clave para desarrollar software m\u00e1s seguro.","title":"6. Reflexi\u00f3n"},{"location":"reflexion/#reflexion-sobre-comparacion-de-la-infraestructura-de-seguridad-de-los-lenguajes","text":"Tras haber visto los contenidos de esta unidad, me he dado cuenta de que la seguridad en la programaci\u00f3n es algo mucho m\u00e1s amplio de lo que pensaba en un principio. Cre\u00eda que bastaba con usar un lenguaje \u201cseguro\u201d, estandarizado y digamos, \"popular\". Pero ahora entiendo que la seguridad depende de muchos factores como el lenguaje, el entorno donde se ejecuta el programa y las medidas de protecci\u00f3n adicionales que se utilicen. Me ha parecido interesante comparar lenguajes como Python y Java . Creo que Python es muy c\u00f3modo para programar y evita muchos errores comunes, como los relacionados con la memoria, lo que lo hace bastante seguro. Sin embargo, tambi\u00e9n he visto que Python no tiene un sistema de seguridad tan estricto integrado, por lo que si alguien consigue ejecutar c\u00f3digo malicioso, puede causar bastantes problemas en el sistema. Por otro lado, creo que lenguajes como Java o .NET est\u00e1n m\u00e1s enfocados a la seguridad. Incorporan controles como la verificaci\u00f3n del c\u00f3digo, la gesti\u00f3n de permisos y la separaci\u00f3n de privilegios, lo que permite ejecutar aplicaciones de forma m\u00e1s controlada. Aunque puedan ser algo m\u00e1s complejos, ofrecen un mayor nivel de protecci\u00f3n, sobre todo en aplicaciones grandes o cr\u00edticas. Tambi\u00e9n me ha llamado mucho la atenci\u00f3n el concepto de sandboxing . Herramientas como Firejail o Docker permiten ejecutar programas de forma aislada, evitando que afecten al resto del sistema. Esto me parece muy \u00fatil, tanto para probar software como para proteger el equipo frente a posibles amenazas. Como conclusi\u00f3n, esta unidad me ha servido para entender que la seguridad no depende de una sola cosa, sino de aplicar varias capas de protecci\u00f3n. Elegir bien el lenguaje, programar de forma correcta y usar entornos aislados cuando sea necesario es clave para desarrollar software m\u00e1s seguro.","title":"Reflexi\u00f3n sobre comparaci\u00f3n de la infraestructura de seguridad de los lenguajes"},{"location":"sandbox/","text":"Ejecuci\u00f3n en Sandbox En este apartado voy a utilizar la herramienta de sandboxing Firejail . Me va a permitir ejecutar el programa Lavadero de forma aislada a mi sistema, limitando lo que puede ver y hacer. Dentro de esta herramienta se encuentra Firetools , que b\u00e1sicamente es la interfaz gr\u00e1fica de Firejail . Nos permite lanzar la herramienta desde fuera del terminal y muestra las aplicaciones activas. 1. Instalaci\u00f3n y ejecuci\u00f3n de la herramienta En primer lugar, instalo la herramienta y la ejecuto. 2. Creaci\u00f3n de perfil seguro En segundo lugar, desde la herramienta lanzo el terminal con el perfil seguro corriendo. En Emulador - Clic derecho - Editar propiedades... Copio la orden del lanzador de la terminal y se la paso a la herramienta para crear un perfil seguro que se va a ejecutar en esa terminal. Una vez le doy a Done , se lanza el terminal en el que estar\u00eda el perfil seguro. Podemos ver el PID y la ruta del perfil. 3. Ejecuci\u00f3n del programa Con python3 ejectuto la aplicaci\u00f3n en el sandbox. En la siguiente captura podemos observar uno de los errores que contiene el programa. Se muestra porque para la prueba en sandbox he escogido las versiones de c\u00f3digo sin corregir. Se demuestra que todo queda aislado en este entorno.","title":"5. Ejecuci\u00f3n en Sandbox"},{"location":"sandbox/#ejecucion-en-sandbox","text":"En este apartado voy a utilizar la herramienta de sandboxing Firejail . Me va a permitir ejecutar el programa Lavadero de forma aislada a mi sistema, limitando lo que puede ver y hacer. Dentro de esta herramienta se encuentra Firetools , que b\u00e1sicamente es la interfaz gr\u00e1fica de Firejail . Nos permite lanzar la herramienta desde fuera del terminal y muestra las aplicaciones activas.","title":"Ejecuci\u00f3n en Sandbox"},{"location":"sandbox/#1-instalacion-y-ejecucion-de-la-herramienta","text":"En primer lugar, instalo la herramienta y la ejecuto.","title":"1. Instalaci\u00f3n y ejecuci\u00f3n de la herramienta"},{"location":"sandbox/#2-creacion-de-perfil-seguro","text":"En segundo lugar, desde la herramienta lanzo el terminal con el perfil seguro corriendo. En Emulador - Clic derecho - Editar propiedades... Copio la orden del lanzador de la terminal y se la paso a la herramienta para crear un perfil seguro que se va a ejecutar en esa terminal. Una vez le doy a Done , se lanza el terminal en el que estar\u00eda el perfil seguro. Podemos ver el PID y la ruta del perfil.","title":"2. Creaci\u00f3n de perfil seguro"},{"location":"sandbox/#3-ejecucion-del-programa","text":"Con python3 ejectuto la aplicaci\u00f3n en el sandbox. En la siguiente captura podemos observar uno de los errores que contiene el programa. Se muestra porque para la prueba en sandbox he escogido las versiones de c\u00f3digo sin corregir. Se demuestra que todo queda aislado en este entorno.","title":"3. Ejecuci\u00f3n del programa"},{"location":"tests/","text":"Tests En este apartado adjunto la carpeta tests , que contiene el archivo con el c\u00f3digo de todos los tests realizados en el apartado Pruebas Descargar tests","title":"8. Tests"},{"location":"tests/#tests","text":"En este apartado adjunto la carpeta tests , que contiene el archivo con el c\u00f3digo de todos los tests realizados en el apartado Pruebas Descargar tests","title":"Tests"}]}